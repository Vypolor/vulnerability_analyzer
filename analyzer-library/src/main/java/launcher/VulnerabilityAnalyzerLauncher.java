package launcher;

import report.CppFileReportInformation;
import report.ReportCreator;
import report.ReportInformation;
import utils.Constants;
import utils.FileHelper;
import vulnerabilities.Vulnerability;
import vulnerabilities.VulnerabilityFactory;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public class VulnerabilityAnalyzerLauncher {

    private final List<String> activeVulnerability;
    private final String pathToSourceFile;
    private final String pathToReportFolder;

    public VulnerabilityAnalyzerLauncher(List<String> activeAbstractVulnerability
            , String pathToSourceFile, String pathToReportFolder) {
        this.activeVulnerability = activeAbstractVulnerability;
        this.pathToSourceFile = pathToSourceFile;
        this.pathToReportFolder = pathToReportFolder;
    }

    public void execute() {
        File reportFolder = new File(pathToReportFolder);
        FileHelper.recursiveDelete(reportFolder);
        reportFolder.mkdir();
        File file = new File(pathToSourceFile);
        if (file.isFile()) {
            launchAnalysis(pathToSourceFile, pathToReportFolder);
        } else if (file.isDirectory()) {
            List<String> fileList = FileHelper.readCppFilesFromDirectory(pathToSourceFile);
            List<CppFileReportInformation> reportInformation = new ArrayList<>();
            for (String curFile : fileList) {
                File sourceFile = new File(curFile);
                String reportPath = calculateReportPath(curFile);
                CppFileReportInformation fileReport = new CppFileReportInformation(curFile
                        , reportPath + Constants.BACKSLASH
                        + sourceFile.getName().replace(Constants.POINT_CPP, Constants.EMPTY_STRING)
                        + "_" + Constants.REPORT_FILE_NAME
                        , launchAnalysis(curFile, reportPath));
                reportInformation.add(fileReport);
            }
            ReportCreator.createGeneralHtmlReport(pathToSourceFile, pathToReportFolder, reportInformation);
        }
    }

    private boolean launchAnalysis(String pathToFile, String filePathToReportFolder) {
        List<String> sourceCode = FileHelper.readDataFromCppFile(pathToFile);
        VulnerabilityFactory factory = new VulnerabilityFactory();
        List<ReportInformation> reportInformation = new ArrayList<>();
        for (String vulnerabilityName : activeVulnerability) {
            Vulnerability vulnerability = factory.getVulnerabilityInstance(vulnerabilityName);
            List<ReportInformation> curVulnerabilityReportInformation = vulnerability.checkRules(sourceCode);
            if (curVulnerabilityReportInformation.size() != 0) {
                reportInformation.addAll(curVulnerabilityReportInformation);
            }
        }
        File file = new File(pathToFile);
        String fileName = file.getName().replace(Constants.POINT_CPP, Constants.EMPTY_STRING);
        reportInformation.sort(Comparator.comparingInt(ReportInformation::getLineNumber));
        FileHelper.createDirs(filePathToReportFolder, pathToReportFolder);
        ReportCreator.createHtmlReport(pathToFile, filePathToReportFolder, reportInformation, fileName);
        return reportInformation.size() == 0;
    }

    private String calculateReportPath(String curFile) {
        File file = new File(curFile);
        String pathDifference = curFile.replace(pathToSourceFile, Constants.EMPTY_STRING);
        String resultPath = (pathToReportFolder + pathDifference).replace(file.getName(), Constants.EMPTY_STRING);
        return resultPath.substring(0, resultPath.length() - 1);
    }
}
