package vulnerabilities.impl;

import report.ReportInformation;
import utils.Constants;
import vulnerabilities.Vulnerability;
import vulnerabilities.rule.Rule;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class BufferOverflowVulnerability extends Vulnerability {

    private final List<Rule> validationRules;

    public BufferOverflowVulnerability() {
        validationRules = initializeRules(this);
    }

    public BufferOverflowVulnerability(List<Rule> validationRules) {
        this.validationRules = validationRules;
    }

    public List<Rule> getValidationRules() {
        return validationRules;
    }

    @Override
    public List<ReportInformation> checkRules(List<String> sourceCode) {
        List<ReportInformation> result = new ArrayList<>();
        for (Rule curRule : validationRules) {
            Pattern pattern = Pattern.compile(curRule.getMask());
            Matcher matcher;
            int codeStringNumber = 0;
            for (String curCodeString : sourceCode) {
                ++codeStringNumber;
                String curStringWithoutTab = curCodeString.replace("\t", "");
                curStringWithoutTab = curStringWithoutTab.trim();
                matcher = pattern.matcher(curStringWithoutTab);
                if (matcher.find()) {
                    if (curRule.getRuleName().equals("Static array definition ")
                            && (curStringWithoutTab.contains("return")) || (curStringWithoutTab.contains("-"))) {
                        break;
                    } else {
                        ReportInformation reportInformation = new ReportInformation(
                                codeStringNumber + ": " + curStringWithoutTab
                                , Constants.BUFFER_OVERFLOW
                                , curRule
                                , codeStringNumber);
                        result.add(reportInformation);
                    }
                }
            }
        }
        return result;
    }
    /*
    List<Rule> bufferOverflowRules = Arrays.asList(
                new Rule("Using an unsafe function ", "gets"
                        , "Using function 'gets(char *buffer)' is unsafe", "Better use 'fgets(char *string, int count, FILE *stream)'"),
                new Rule("Using an unsafe function ", "strcpy", "Using function 'strcpy(char *destination, const char *source)' is unsafe"
                        , "Better use 'strncpy(char *destination, const char *source, size_t count)'"),
                new Rule("Using an unsafe function", "strcat", "Using function 'strcat(char *destination, const char *source)' is unsafe"
                        , "Better use 'strncat(char *destination, const char *source, size_t count)'"),
                new Rule("Using an unsafe function", "sprintf", "Using function 'sprintf(char *string, const char *format, ...)' is unsafe"
                        , "Better use 'std::cout << \"your_string\"'"),
                new Rule("Using an unsafe function", "memcpy", "Using function 'memcpy(void *restrict dest, const void *restrict src, size_t count)' is unsafe"
                        , "Better use 'memcpy_s(void *restrict dest, rsize_t destsz, const void *restrict src, rsize_t count)'"),
                new Rule("Using an unsafe function", "strlen", "Using function 'strlen(const char *s)' is unsafe"
                        , "Better use 'strnlen(const char *s, size_t maxlen)'"),
                new Rule("Using an unsafe function", "vsprintf", "Using function 'vsprintf(char *buffer,const char *format,va_list argptr)' is unsafe"
                        , "Better use 'vsprintf_s(char *buffer,size_t numberOfElements,const char *format,va_list argptr)'"),
                new Rule("Static array definition ", "(static|^)\s?([a-zA-Z0-9]+)\s?([a-zA-Z]+)\s?(\\[.+?\\]);$", "Static array definition"
                        , "Better use dynamic memory allocation (int *arr = new int [const])")
        );
     */
}
