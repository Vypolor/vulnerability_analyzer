package vulnerabilities.impl;

import report.ReportInformation;
import utils.Constants;
import vulnerabilities.Vulnerability;
import vulnerabilities.rule.Rule;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

//Gafar
public class RandomCryptographicNumbersVulnerability extends Vulnerability {

    private final List<Rule> validationRules;

    public RandomCryptographicNumbersVulnerability() {
        validationRules = initializeRules(this);
    }

    public List<Rule> getValidationRules() {
        return validationRules;
    }

    @Override
    public List<ReportInformation> checkRules(List<String> sourceCode) {
        List<ReportInformation> result = new ArrayList<>();
        for (Rule curRule : validationRules) {
            boolean srandFounded = false;

            if (curRule.getRuleName().equals("rand() without srand(...)")) {
                String findSrandRegex = "(\\W|)srand\\(.*?\\)";
                String findBraceStart = "\\{";
                String findBraceEnd = "\\}";
                String findMainRegex = "int main\\(.*?\\{";
                int braceCounter = 1;
                int codeStringNumber = 0;
                List<String> mainCode = new ArrayList<>();
                Pattern pattern = Pattern.compile(findMainRegex);
                Matcher matcher;
                boolean isMain = false;
                for (String curCodeString : sourceCode) {
                    if (!isMain) { // find start of main
                        ++codeStringNumber;
                        String curStringWithoutTab = curCodeString.replace("\t", "");
                        matcher = pattern.matcher(curStringWithoutTab);
                        if (matcher.find()) {
                            mainCode.add(curStringWithoutTab);
                            isMain = true;
                            continue;
                        }
                    }
                    else { // start of main founded => find all code of main thanks to '{' and '}'
                        if (braceCounter == 0) { // all main code founded => find srand(...) function
                            for (String mainCodeString : mainCode) {
                                pattern = Pattern.compile(findSrandRegex);
                                matcher = pattern.matcher(mainCodeString);
                                if (matcher.find()) {
                                    srandFounded = true;
                                    break;
                                }
                            }
                            if (srandFounded) break;
                        }
                        ++codeStringNumber;
                        String curStringWithoutTab = curCodeString.replace("\t", "");
                        mainCode.add(curStringWithoutTab);
                        pattern = Pattern.compile(findBraceStart);
                        matcher = pattern.matcher(curStringWithoutTab);
                        if (matcher.find()) {
                            ++braceCounter;
                        }
                        else {
                            pattern = Pattern.compile(findBraceEnd);
                            matcher = pattern.matcher(curStringWithoutTab);
                            if (matcher.find()) {
                                --braceCounter;
                            }
                        }
                    }
                }
                if (!srandFounded) {
                    codeStringNumber = 0;
                    for (String curCodeString : sourceCode) {
                        ++codeStringNumber;
                        String curStringWithoutTab = curCodeString.replace("\t", "");
                        pattern = Pattern.compile(curRule.getMask());
                        matcher = pattern.matcher(curStringWithoutTab);
                        if (matcher.find()) {
                            ReportInformation reportInformation = new ReportInformation(
                                    codeStringNumber + ": " + curStringWithoutTab
                                    , Constants.RANDOM_CRYPTO_NUMBERS
                                    , curRule
                                    , codeStringNumber);
                            result.add(reportInformation);
                        }
                    }
                }
            } else {
                Pattern pattern = Pattern.compile(curRule.getMask());
                Matcher matcher;
                int codeStringNumber = 0;
                for (String curCodeString : sourceCode) {
                    ++codeStringNumber;
                    String curStringWithoutTab = curCodeString.replace("\t", "");
                    matcher = pattern.matcher(curStringWithoutTab);
                    if (matcher.find()) {
                        ReportInformation reportInformation = new ReportInformation(
                                codeStringNumber + ": " + curStringWithoutTab
                                , Constants.RANDOM_CRYPTO_NUMBERS
                                , curRule
                                , codeStringNumber);
                        result.add(reportInformation);
                    }
                }
            }
        }
        return result;
    }

    public void createRules() {
        List<Rule> rules = Arrays.asList(
                new Rule("Seed std:time"
                        , ".*(\\.seed){1}.*(time){1}.*"
                        , "Possible incompatibility of operating systems"
                        , "Better use std::random_device as seed"),
                new Rule("Seed constant"
                        , ".*((\\.seed|srand|drand48|erand48|jrand48|lrand48|nrand48|seed48)\\()[0-9]+\\)"
                        , "Constant as seed"
                        , "Better use non constant value as seed"),
                new Rule("rand() without srand(...)"
                        , "(\\W)rand\\(\\)"
                        , "Using rand() without calling srand(...) can result in identical output sequences"
                        , "Better use srand(unsigned int seed) before call rand()")
        );
    }
//        std::mt19937 engine; // mt19937 как один из вариантов
//        engine.seed(std::time(nullptr));
//        /*
//        на случай, если у вас UNIX-чё-то или компилятор не MinGW
//        std::random_device device;
//        engine.seed(device());
}
